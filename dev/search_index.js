var documenterSearchIndex = {"docs":
[{"location":"#FixedMeshRefinement","page":"Home","title":"FixedMeshRefinement","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for FixedMeshRefinement.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#FixedMeshRefinement.Grid","page":"Home","title":"FixedMeshRefinement.Grid","text":"Grid\n\nA struct representing the entire FMR grid, which consists of multiple Levels.\n\nFields\n\nnum_levels::Int: The total number of refinement levels.\nlevels::Vector{Level}: A vector of Level objects.\nbase_dt::Float64: The time step of the coarsest level.\nt::Float64: The current time of the simulation.\nsubcycling::Bool: A boolean indicating whether subcycling in time is enabled.\n\n\n\n\n\n","category":"type"},{"location":"#FixedMeshRefinement.Level","page":"Home","title":"FixedMeshRefinement.Level","text":"Level\n\nA struct representing a single refinement level in the mesh.\n\nFields\n\nindex::Int: Index of the level.\nnum_state_variables::Int: Number of state variables.\nnum_diagnostic_variables::Int: Number of diagnostic variables.\nnum_tmp_variables::Int: Number of temporary variables.\nnum_interior_points::Int: Number of interior grid points.\nnum_ghost_points::Int: Number of ghost points on each side.\nnum_buffer_points::Int: Number of buffer points on each side for inter-level communication.\nnum_transition_points::NTuple{2,Int}: Number of points in the transition zone for mesh refinement.\nnum_boundary_points::NTuple{2,Int}: Number of boundary points on each side (ghost or buffer).\ntime_interpolation_order::Int: Order of time interpolation.\nspatial_interpolation_order::Int: Order of spatial interpolation.\ndomain_box::Tuple{Float64,Float64}: The computational domain (interior) of this level.\nphysical_domain_box::Tuple{Float64,Float64}: The physical domain of the entire grid.\nis_physical_boundary::NTuple{2,Bool}: Indicates if the level boundaries are physical boundaries.\ndx::Float64: Grid spacing.\ndt::Float64: Time step.\nt::Float64: Current time of this level.\nparent_indices::UnitRange{Int}: Range of indices in the parent level that this level covers.\noffset_indices::UnitRange{Int}: Range of indices for OffsetArrays of this level.\n\n\n\n\n\n","category":"type"},{"location":"#Base.show-Tuple{IO, Grid}","page":"Home","title":"Base.show","text":"Base.show(io::IO, grid::Grid)\n\nDisplay a compact summary of the Grid.\n\n\n\n\n\n","category":"method"},{"location":"#Base.show-Tuple{IO, Level}","page":"Home","title":"Base.show","text":"Base.show(io::IO, level::Level)\n\nDisplay a compact summary of the Level.\n\n\n\n\n\n","category":"method"},{"location":"#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, Grid}","page":"Home","title":"Base.show","text":"Base.show(io::IO, ::MIME\"text/plain\", grid::Grid)\n\nDisplay a detailed summary of the Grid structure.\n\n\n\n\n\n","category":"method"},{"location":"#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, Level}","page":"Home","title":"Base.show","text":"Base.show(io::IO, ::MIME\"text/plain\", level::Level)\n\nDisplay a detailed summary of the Level.\n\n\n\n\n\n","category":"method"},{"location":"#FixedMeshRefinement.apply_transition_zone!-Tuple{Grid, Int64, Bool}","page":"Home","title":"FixedMeshRefinement.apply_transition_zone!","text":"apply_transition_zone!(grid::Grid, l::Int, interp_in_time::Bool)\n\nApply a transition zone to smoothly connect coarse and fine grid solutions at the boundaries of a refinement level. This function blends the fine grid solution with a prolonged solution from the coarse grid.\n\nArguments\n\ngrid::Grid: The grid structure.\nl::Int: The fine level index.\ninterp_in_time::Bool: Whether to use time interpolation.\n\n\n\n\n\n","category":"method"},{"location":"#FixedMeshRefinement.calc_Yn_from_kcs!-Tuple{Any, Any, Any, Any, Bool, Any}","page":"Home","title":"FixedMeshRefinement.calc_Yn_from_kcs!","text":"calc_Yn_from_kcs!(Yn_buffer, yn, kcs, dtc, interp_in_time, dytmp)\n\nCalculate the intermediate Y values needed for Mongwane's subcycling method. These values represent the state on the coarse grid at intermediate times required by the fine grid's time stepping.\n\nArguments\n\nYn_buffer: Buffer to store the calculated Y values.\nyn: State on the coarse grid at the beginning of the step.\nkcs: The RK4 stages from the coarse grid time step.\ndtc::Float64: The coarse grid time step.\ninterp_in_time::Bool: Flag indicating if interpolation in time is needed.\ndytmp: Temporary storage for derivatives.\n\n\n\n\n\n","category":"method"},{"location":"#FixedMeshRefinement.cycle_state!-Tuple{Level}","page":"Home","title":"FixedMeshRefinement.cycle_state!","text":"cycle_state!(level::Level)\n\nShift the time levels of the state variables in a Level. state[i] becomes state[i+1]. This is used to advance the solution in time.\n\n\n\n\n\n","category":"method"},{"location":"#FixedMeshRefinement.fill_buffer!-Tuple{Any, Level, Int64}","page":"Home","title":"FixedMeshRefinement.fill_buffer!","text":"fill_buffer!(u, level::Level, stage::Int)\n\nFill the ghost cells of the solution array u from the Yn_buffer at a specific Runge-Kutta stage. This is part of the subcycling-in-time method. After copying, the buffer is filled with NaN to avoid accidental reuse.\n\nArguments\n\nu: The solution array with ghost cells to be filled.\nlevel::Level: The grid level.\nstage::Int: The RK stage index.\nfill_with_nan::Bool: If true, fill the buffer with NaN to avoid accidental reuse. Defaults to true.\n\n\n\n\n\n","category":"method"},{"location":"#FixedMeshRefinement.fine_to_coarse_index-Tuple{Level, Int64}","page":"Home","title":"FixedMeshRefinement.fine_to_coarse_index","text":"fine_to_coarse_index(fine_level::Level, fidx::Int) -> Int\n\nConvert a fine grid index fidx to the corresponding coarse grid index. This function is not defined for the base level. An error is thrown if the fine grid point does not align with any coarse grid point.\n\n\n\n\n\n","category":"method"},{"location":"#FixedMeshRefinement.get_boundary_indices-Tuple{Level}","page":"Home","title":"FixedMeshRefinement.get_boundary_indices","text":"get_boundary_indices(level::Level) -> NTuple{2,StepRange{Int,Int}}\n\nReturn the indices of the boundary points on each side (ghost or buffer).\n\n\n\n\n\n","category":"method"},{"location":"#FixedMeshRefinement.get_diagnostic_state-Tuple{Level}","page":"Home","title":"FixedMeshRefinement.get_diagnostic_state","text":"get_diagnostic_state(level::Level)\n\nReturn the diagnostic state variables of the level as an OffsetArray.\n\n\n\n\n\n","category":"method"},{"location":"#FixedMeshRefinement.get_interior_indices-Tuple{Level}","page":"Home","title":"FixedMeshRefinement.get_interior_indices","text":"get_interior_indices(level::Level) -> UnitRange{Int}\n\nReturn the indices of the interior grid points.\n\n\n\n\n\n","category":"method"},{"location":"#FixedMeshRefinement.get_maximum_grid_points-Tuple{Level}","page":"Home","title":"FixedMeshRefinement.get_maximum_grid_points","text":"get_maximum_grid_points(level::Level) -> Int\n\nReturn the maximum number of grid points at this level (including ghost, buffer and unused points).\n\n\n\n\n\n","category":"method"},{"location":"#FixedMeshRefinement.get_offset_indices-Tuple{Level}","page":"Home","title":"FixedMeshRefinement.get_offset_indices","text":"get_offset_indices(level::Level) -> UnitRange{Int}\n\nReturn the indices of the grid points in the OffsetArray of the level.\n\n\n\n\n\n","category":"method"},{"location":"#FixedMeshRefinement.get_rhs_evaluation_indices-Tuple{Level}","page":"Home","title":"FixedMeshRefinement.get_rhs_evaluation_indices","text":"get_rhs_evaluation_indices(level::Level) -> UnitRange{Int}\n\nReturn the indices that requires evaluation of the right-hand side.\n\n\n\n\n\n","category":"method"},{"location":"#FixedMeshRefinement.get_rk4_tmp_state-Tuple{Level}","page":"Home","title":"FixedMeshRefinement.get_rk4_tmp_state","text":"get_rk4_tmp_state(level::Level)\n\nReturn a temporary array with the same size as the state variables of the level as an OffsetArray.\n\n\n\n\n\n","category":"method"},{"location":"#FixedMeshRefinement.get_rk_stage-Tuple{Level, Int64}","page":"Home","title":"FixedMeshRefinement.get_rk_stage","text":"get_rk_stage(level::Level, i::Int)\n\nReturn the i-th intermediate state k_i for the Runge-Kutta time stepping scheme as an OffsetArray.\n\n\n\n\n\n","category":"method"},{"location":"#FixedMeshRefinement.get_state","page":"Home","title":"FixedMeshRefinement.get_state","text":"get_state(level::Level, i::Int=0)\n\nReturn the state variables of the level as an OffsetArray. The optional argument i specifies the time level, where i=0 corresponds to the current time level n, i=-1 to n-1, etc.\n\n\n\n\n\n","category":"function"},{"location":"#FixedMeshRefinement.get_tmp_state-Tuple{Level}","page":"Home","title":"FixedMeshRefinement.get_tmp_state","text":"get_tmp_state(level::Level)\n\nReturn the temporary state variables of the level as an OffsetArray.\n\n\n\n\n\n","category":"method"},{"location":"#FixedMeshRefinement.get_total_grid_points-Tuple{Level}","page":"Home","title":"FixedMeshRefinement.get_total_grid_points","text":"get_total_grid_points(level::Level) -> Int\n\nReturn the total number of grid points at this level (including ghost and buffer points).\n\n\n\n\n\n","category":"method"},{"location":"#FixedMeshRefinement.get_x-Tuple{Level}","page":"Home","title":"FixedMeshRefinement.get_x","text":"get_x(level::Level)\n\nReturn the grid point coordinates of the level as an OffsetArray.\n\n\n\n\n\n","category":"method"},{"location":"#FixedMeshRefinement.prolongate!-Tuple{Grid, Int64, Bool}","page":"Home","title":"FixedMeshRefinement.prolongate!","text":"prolongate!(grid::Grid, l::Int, interp_in_time::Bool)\n\nPerform prolongation from a coarse grid (l-1) to a fine grid (l). This function fills the ghost cells of the fine grid by interpolating the data from the coarse grid in space and, optionally, in time.\n\nArguments\n\ngrid::Grid: The grid structure.\nl::Int: The fine level index.\ninterp_in_time::Bool: Whether to use time interpolation.\n\n\n\n\n\n","category":"method"},{"location":"#FixedMeshRefinement.prolongate_mongwane!-Tuple{Grid, Int64, Bool}","page":"Home","title":"FixedMeshRefinement.prolongate_mongwane!","text":"prolongate_mongwane!(grid::Grid, l::Int, interp_in_time::Bool)\n\nPerform prolongation from a coarse grid (l-1) to a fine grid (l) using Mongwane's subcycling-in-time method. This is used to set the ghost cell data for the fine grid when subcycling is enabled.\n\nArguments\n\ngrid::Grid: The grid structure.\nl::Int: The fine level index.\ninterp_in_time::Bool: Whether to use time interpolation for the coarse grid state.\n\n\n\n\n\n","category":"method"},{"location":"#FixedMeshRefinement.restrict_injection!-Tuple{Grid, Int64}","page":"Home","title":"FixedMeshRefinement.restrict_injection!","text":"restrict_injection!(grid::Grid, l::Int; apply_trans_zone=false)\n\nPerform restriction from a fine grid (l+1) to a coarse grid (l). This operation transfers data from a finer grid to a coarser grid. Currently, it uses injection by taking the values from the fine grid at the locations corresponding to the coarse grid points.\n\nArguments\n\ngrid::Grid: The grid structure.\nl::Int: The coarse level index.\napply_trans_zone::Bool: If true, the restriction is only applied outside of the transition zones. Defaults to false.\n\n\n\n\n\n","category":"method"},{"location":"#FixedMeshRefinement.rk4!-Tuple{Level, Function, Any}","page":"Home","title":"FixedMeshRefinement.rk4!","text":"rk4!(level::Level, f::Function, p; mongwane::Bool=false)\n\nPerform a single step of the classic 4th-order Runge-Kutta (RK4) method on a given level. It advances the solution by one time step dt.\n\nArguments\n\nlevel::Level: The grid level to be updated.\nf::Function: The function that computes the right-hand side of the ODEs. It should have the signature f(level, k, u, p, t).\np: Parameters to be passed to the RHS function f.\nmongwane::Bool: If true, enables special buffer filling for Mongwane's subcycling method. Defaults to false.\n\n\n\n\n\n","category":"method"},{"location":"#FixedMeshRefinement.rk4_dense_output_y!-NTuple{5, Any}","page":"Home","title":"FixedMeshRefinement.rk4_dense_output_y!","text":"rk4_dense_output_y!(y, theta, h, yn, k)\n\nCalculate the dense output for a 4th-order Runge-Kutta method at a fractional time theta within a time step h. This is used for interpolation in time within a single time step.\n\nArguments\n\ny: The output array for the interpolated state.\ntheta::Float64: The fractional time within the interval [0, 1].\nh::Float64: The time step size.\nyn: The state at the beginning of the time step.\nk: A vector of RK4 stages k1 through k4.\n\n\n\n\n\n","category":"method"},{"location":"#FixedMeshRefinement.searchsortednearest-Tuple{AbstractVector, Any}","page":"Home","title":"FixedMeshRefinement.searchsortednearest","text":"searchsortednearest(a::AbstractVector, x)\n\nFind the index of the element in a sorted array a that is nearest to x.\n\n\n\n\n\n","category":"method"},{"location":"#FixedMeshRefinement.shift_grid_boundaries!-Tuple{Grid, Tuple{Int64, Int64}}","page":"Home","title":"FixedMeshRefinement.shift_grid_boundaries!","text":"shift_grid_boundaries!(grid::Grid, num_shift_points::NTuple{2,Int}; func_fill_extended::Function=(i, level) -> 0.0)\n\nShift the boundary of the grid by a given number of points; as a prerequisite, all levels must align with the physical boundary. If the number of shift points is positive, the grid will be extended, otherwise it will be shrunk. The tuple num_shift_points is the number of points to shift on the left and right boundaries, respectively.\n\nArguments\n\ngrid::Grid: The grid to shift boundaries of\nnum_shift_points::NTuple{2,Int}: Number of points to shift on left and right boundaries\nfunc_fill_extended::Function=(i, level) -> 0.0: Function to compute fill values, takes index and level as arguments\n\n\n\n\n\n","category":"method"},{"location":"#FixedMeshRefinement.shift_level_boundaries!-Tuple{Level, Tuple{Int64, Int64}}","page":"Home","title":"FixedMeshRefinement.shift_level_boundaries!","text":"shift_level_boundaries!(level::Level, num_shift_points::NTuple{2,Int}; func_fill_extended::Function=(i, level) -> 0.0)\n\nShift the boundary of a Level by a given number of points, as a prerequisite, the level must align with the physical boundary.\n\n\n\n\n\n","category":"method"},{"location":"#FixedMeshRefinement.spatial_interpolate!-NTuple{4, Any}","page":"Home","title":"FixedMeshRefinement.spatial_interpolate!","text":"spatial_interpolate!(res, u, i, order)\n\nPerforms spatial interpolation for prolongation using a set of predefined stencils of a given order. The result is stored in res. The interpolation uses values from u around index i.\n\nArguments\n\nres: The destination array for the interpolated values.\nu: The source data array.\ni::Int: The index in u to center the interpolation stencil.\norder::Int: The order of spatial interpolation (1 through 5 are supported).\n\n\n\n\n\n","category":"method"},{"location":"#FixedMeshRefinement.step!-Tuple{Grid, Function, Any}","page":"Home","title":"FixedMeshRefinement.step!","text":"step!(\n    grid::Grid,\n    f::Function,\n    p;\n    mongwane::Bool=false,\n    apply_trans_zone::Bool=false,\n)\n\nAdvance the solution on the entire grid by one time step of the coarsest level. This function orchestrates the time stepping across all refinement levels, handling subcycling, prolongation, restriction, and application of transition zones.\n\nArguments\n\ngrid::Grid: The FMR grid structure.\nf::Function: The function that computes the right-hand side of the ODEs. It should have the signature f(level, k, u, p, t).\np: Parameters to be passed to the RHS function f.\nmongwane::Bool: If true, enables Mongwane's subcycling method. Defaults to false.\napply_trans_zone::Bool: If true, applies transition zones to smooth inter-grid boundaries. Defaults to false.\n\n\n\n\n\n","category":"method"},{"location":"#FixedMeshRefinement.transition_profile-Tuple{Any, Any, Any}","page":"Home","title":"FixedMeshRefinement.transition_profile","text":"transition_profile(xl, xh, x; type=1)\n\nCompute a transition profile value at x between xl and xh. This is used to smoothly blend solutions in transition zones.\n\nArguments\n\nxl::Float64: The lower bound of the transition interval.\nxh::Float64: The upper bound of the transition interval.\nx::Float64: The point at which to evaluate the profile.\ntype::Int: The type of transition profile (1: boxstep, 2: smoothstep, 3: smootherstep).\n\n\n\n\n\n","category":"method"},{"location":"#FixedMeshRefinement.typetol-Tuple{Type{<:AbstractFloat}}","page":"Home","title":"FixedMeshRefinement.typetol","text":"typetol(TF::Type{<:AbstractFloat})\n\nReturn a tolerance value for a given float type TF. The tolerance is calculated as eps(TF)^(4/5). This is useful for setting default tolerances in numerical algorithms where machine precision is a factor.\n\nArguments\n\nTF::Type{<:AbstractFloat}: The floating point type.\n\nReturns\n\nA tolerance value of the same floating point type.\n\nExamples\n\njulia> typetol(Float64)\n3.666852862501036e-11\n\njulia> typetol(Float32)\n2.422181f-5\n\n\n\n\n\n","category":"method"}]
}
